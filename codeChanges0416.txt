
Triangle CubieMesh::getNearest(ofVec3f _pnt){
	if (triangles.size()==0) {
		cout << "Triangles has no content ERROR" << endl;
		addTriangle(0,1,2,ofVec3f(0,0,0),ofVec3f(0,0,0),ofVec3f(0,0,0),ofVec3f(0,0,1),ofFloatColor(0,1));
	}
	Triangle r = triangles[0];
	float distance = r.getCenter().distance(_pnt);
	for(auto tIter = triangles.begin() + 1; tIter != triangles.end(); tIter++){
		float tDist = tIter->getCenter().distance(_pnt);
		if(tDist < distance){
			distance = tDist;
			r = *tIter;
		}
	}
	return r;

}







//---------------------------------------------------------------------------------------------
void puzzle::rotateByIDandAxisNew(int id, SG_VECTOR axis, bool dir, float angle){
	//it receives the id of a cubie,the axis and the direction of rotation
	//it looks for the other 9 ids, according to the axis
	//and makes those 9 myCubies[]->faceRotate
	int gridSquared=gridSize*gridSize;
	counter = 0;

	//look for positon of cubie on the 3d data structure
	selX =myCubies[id]->getXpos();
	selY =myCubies[id]->getYpos();
	selZ =myCubies[id]->getZpos();
	//now we ask for the cubies on that axis
	if(axis.x != 0){
		for (int i=0;i<numPieces;i++) {
			if (myCubies[i]->getXpos()==selX) {
				if (myCubies[i]->getNumObjs()>0) {
					selected[counter]=i;
					counter++;
				}
			}
		}
		//rearrange3dArrayNew(0,selX,dir);
	}else if(axis.y != 0){
		for (int i=0;i<numPieces;i++) {
			if (myCubies[i]->getYpos()==selY) {
				if (myCubies[i]->getNumObjs()>0) {
					selected[counter]=i;
					counter++;
				}
			}
		}
		//rearrange3dArrayNew(1,selY,dir);
	}else{
		//if the move is on a z axis
		for (int i=0;i<numPieces;i++) {
			if (myCubies[i]->getZpos()==selZ) {
				if (myCubies[i]->getNumObjs()>0) {
					selected[counter]=i;
					counter++;
				}
			}
		}
		//rearrange3dArrayNew(2,selZ,dir);
	}

	//look for rotation constraints
	//user could be dragging the rotating face beyond he 90 deg move

	if(myCubies[selected[0]]->masterAngle < 90 && myCubies[selected[0]]->masterAngle > -90){



		//if(ofSign(myCubies[selected[0]]->masterAngle) > 0){
		if(dir){
			//positive rotation in relation to original position
			if((myCubies[selected[0]]->masterAngle + angle) > 90){
				//move until 90
				angle = 90 - myCubies[selected[0]]->masterAngle;

				for(int i=0;i<counter;i++){
					//rearrange = myCubies[selected[i]]->faceRotate(axis,dir,angle);
					myCubies[selected[i]]->faceRotate(axis,dir,angle);
				}
			}else{
				//now we tell the 9 selected cubies to rotate
				//bool rearrange=false;
				for(int i=0;i<counter;i++){
					//rearrange = myCubies[selected[i]]->faceRotate(axis,dir,angle);
					myCubies[selected[i]]->faceRotate(axis,dir,angle);
				}
			}
		}else{
			//negative rotation in relation to original position
			if((myCubies[selected[0]]->masterAngle - angle) < -90){
				//move until -90
				angle = -90 - myCubies[selected[0]]->masterAngle;
				angle=abs(angle);
				for(int i=0;i<counter;i++){
					//rearrange = myCubies[selected[i]]->faceRotate(axis,dir,angle);
					myCubies[selected[i]]->faceRotate(axis,dir,angle);
				}
			}else{
				//now we tell the 9 selected cubies to rotate
				//bool rearrange=false;
				for(int i=0;i<counter;i++){
					//rearrange = myCubies[selected[i]]->faceRotate(axis,dir,angle);
					myCubies[selected[i]]->faceRotate(axis,dir,angle);
				}
			}
		}
	}else if(myCubies[selected[0]]->masterAngle == 90){
		if(!dir){
			if((myCubies[selected[0]]->masterAngle - angle) < 90){
				for(int i=0;i<counter;i++){
					//rearrange = myCubies[selected[i]]->faceRotate(axis,dir,angle);
					myCubies[selected[i]]->faceRotate(axis,dir,angle);
				}
			}
		}
	}else if(myCubies[selected[0]]->masterAngle == -90){
		if(dir){
			//negative rotation in relation to original position
			if((myCubies[selected[0]]->masterAngle + angle) > -90){
				for(int i=0;i<counter;i++){
					//rearrange = myCubies[selected[i]]->faceRotate(axis,dir,angle);
					myCubies[selected[i]]->faceRotate(axis,dir,angle);
				}
			}
		}
	}

	//rearrange cubies position
	//do we do this after we complete 90 deg rotation???
	/////it doesnt matter, it can be that instant, since the 3d array is only looked upon before moving
	/////the animation will lock selection of new cubie, so on ly one movement is done at a time
	/////so the re-aranging of numbers can happen "during" the animation
}
//--------------------------------------------------------------------------------------



void game::makeMove(ofVec3f _pnt){
	//SG_POINT axis;
	// get angle of gesture
	double dragDist=sqrt((_pnt.y*_pnt.y)+(_pnt.x*_pnt.x));
	if(bHaveAxis == false){
		if(dragDist > 75){

			dragAngle = atan2(_pnt.y,_pnt.x);//atan2(newPt.Y - twistStartPoint.Y, newPt.X - twistStartPoint.X);

			double offset = 100000;
			int closest=-1;
			for (int i = 0; i < 6; i++)
			{
				double dist= abs(dragAngle-gestureAngles[i]);
				double dist2= abs(dragAngle-gestureAngles[i]+(2*3.14159));
				double dist3= abs(dragAngle-gestureAngles[i]-(2*3.14159));
				if (dist < offset)
				{
					offset = dist;
					closest = i;
				} 
				if (dist2 < offset)
				{
					offset = dist2;
					closest = i;
				} 
				if (dist3 < offset)
				{
					offset = dist3;
					closest = i;
				} 
				
			}
	
			cubiePos=myPuzzle->getCubieInfo(myPuzzle->activeCubie);
			ofVec3f normal = myPuzzle->activeTriangle.getNormal();
//			ofVec3f normal=camPosition-ofVec3f(posP.x, posP.y, posP.z);
			int normalNum=-1;
			int normalAng=0;

			// this one is easy since we're only dealing with six absolute directions... so we can see which vector of the normal is the most extreme
			if (abs(normal.x)>abs(normal.y) && abs(normal.x)>abs(normal.z)) {
				// x axis is most prominent
				normalAng=0;
				if (normal.x>0) {
					normalNum=0;
				} else {
					normalNum=1;
				}

			} else if (abs(normal.y)>abs(normal.z)) {
				// y axis is most prominent
				normalAng=1;
				if (normal.y>0) {
					normalNum=2;
				} else {
					normalNum=3;
				}
			} else {
				// z axis is most prominent
				normalAng=2;
				if (normal.z>0) {
					normalNum=4;
				} else {
					normalNum=5;
				}

			}



			if (closest==1 || closest==0) {
				// x axis
				bHaveAxis = true;


				if (normalAng==1) {
					
					// rotate on z
					
					axis.x = 0;
					axis.y = 0;
					axis.z = 1;
					dir=true;
					if(myPuzzle->getCubieInfo(myPuzzle->activeCubie).y >= 1) {
						dir = false;
					}

					if (closest==1) {
						dir=!dir;
					}
					rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,10);

				} else {

					// rotate on y
					
					axis.x = 0;
					axis.y = 1;
					axis.z = 0;

					dir=true;
					if(myPuzzle->getCubieInfo(myPuzzle->activeCubie).z <= 1) {
						dir = false;
					}
					if (closest==1) {
						dir=!dir;
					}
					rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,10);

				}


			}


			if (closest==3 || closest==2) {
				// y axis
				bHaveAxis = true;


				if (normalAng==0) {
					// rotate on z
					axis.x = 0;
					axis.y = 0;
					axis.z = 1;
					dir=true;
					if(myPuzzle->getCubieInfo(myPuzzle->activeCubie).x <= 1) {
						dir = false;
					}
					if (closest==3) {
						dir=!dir;
					}
					rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,10);

				} else {
					// rotate on x
					axis.x = 1;
					axis.y = 0;
					axis.z = 0;

					dir=false;
					if(myPuzzle->getCubieInfo(myPuzzle->activeCubie).z <= 1) {
						dir = true;
					}
					if (closest==3) {
						dir=!dir;
					}

					rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,10);

				}


			}




			if (closest==4 || closest==5) {
				// z axis
				bHaveAxis = true;

				if (normalAng==0) {
					// rotate on y
					axis.x = 0;
					axis.y = 1;
					axis.z = 0;
					dir=false;
					if(myPuzzle->getCubieInfo(myPuzzle->activeCubie).x <= 1) {
						dir = true;
					}
					if (closest==5) {
						dir=!dir;
					}
					rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,10);

				} else {
					// rotate on x
					axis.x = 1;
					axis.y = 0;
					axis.z = 0;

					dir=true;
					if(myPuzzle->getCubieInfo(myPuzzle->activeCubie).y <= 1) {
						dir = false;
					}
					if (closest==5) {
						dir=!dir;
					}
					rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,10);

				}


			}
			


	}

	}else{
		

		if (((dragDist-lastDragDistance)/300)>.5) {
			rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,5);
		} else if (((dragDist-lastDragDistance)/300)<-.5) {
			rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,-5);
		}
	}
	lastDragDistance=dragDist;
}



void game::unprojectPoint(ofVec3f _pnt){
	unprojectedPoint = picker.unproject(mousePoint, &viewport);
	if(unprojectMode == UP_MODE_MOUSE){
		if(!bDragInput){
			myPuzzle->checkCubiesForHit(unprojectedPoint);
			lastUnprojectedPoint = mousePoint;
			bDragInput = true;
			bHaveAxis = false;
			startMove(mousePoint);
		} else {
			makeMove((mousePoint - lastUnprojectedPoint) * 25.0);
		}
	} else if(unprojectMode == UP_MODE_COLOR){
		myPuzzle->changeFaceColor(unprojectedPoint, newFaceColor);
	}
}

