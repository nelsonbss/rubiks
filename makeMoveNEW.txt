void game::makeMove(ofVec3f _pnt){
	//SG_POINT axis;
	// get angle of gesture
	double dragDist=sqrt((_pnt.y*_pnt.y)+(_pnt.x*_pnt.x));
	if(bHaveAxis == false){
		if(dragDist > 25){

			double dragAngle = atan2(_pnt.y,_pnt.x);//atan2(newPt.Y - twistStartPoint.Y, newPt.X - twistStartPoint.X);

			double offset = 100000;
			int closest=-1;
			for (int i = 0; i < 6; i++)
			{
				double dist= abs(dragAngle-gestureAngles[i]);
				if (dist < offset)
				{
					offset = dist;
					closest = i;
				}
			}
	
			cubiePos=myPuzzle->getCubieInfo(myPuzzle->activeCubie);
			ofVec3f normal = myPuzzle->activeTriangle.getNormal();
			int normalAng=0;
			// this one is easy since we're only dealing with six absolute directions... so we can see which vector of the normal is the most extreme
			if (abs(normal.x)>abs(normal.y) && abs(normal.x)>abs(normal.z)) {
				// x axis is most prominent
				normalAng=0;
			cout << "~~~~~~~~~~~~~~~~~~~~~~~~cubie normal is X" << endl;
			} else if (abs(normal.y)>abs(normal.z)) {
				// y axis is most prominent
				normalAng=1;
			cout << "~~~~~~~~~~~~~~~~~~~~~~~~cubie normal is Y" << endl;
			} else {
				// z axis is most prominent
				normalAng=2;
			cout << "~~~~~~~~~~~~~~~~~~~~~~~~cubie normal is Z" << endl;
			}

			/// version with normals

			/*
			if (closest==1 || closest==0) {
				// x axis
				bHaveAxis = true;//we have to make shure to constrain the first gesture vector


				if (normalAng==1) {
					axis.x = 0;
					axis.y = 0;
					axis.z = 1;
					dir=true;
					if(myPuzzle->getCubieInfo(myPuzzle->activeCubie).y <= 1) {
						dir = false;
					}

					if (closest==1) {
						dir=!dir;
					}
					rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,10);

				} else {
					axis.x = 0;
					axis.y = 1;
					axis.z = 0;

					dir=true;
					if(myPuzzle->getCubieInfo(myPuzzle->activeCubie).z <= 1) {

						dir = false;
					}
					if (closest==1) {
						dir=!dir;
					}
					rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,10);

				}


			}


			if (closest==3 || closest==2) {
				// y axis
				bHaveAxis = true;//we have to make shure to constrain the first gesture vector


				if (normalAng==0) {
					axis.x = 0;
					axis.y = 0;
					axis.z = 1;
					dir=true;
					if(myPuzzle->getCubieInfo(myPuzzle->activeCubie).x <= 1) {
						dir = false;
					}
					if (closest==3) {
						dir=!dir;
					}
					rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,10);

				} else {
					axis.x = 1;
					axis.y = 0;
					axis.z = 0;

					dir=true;
					if(myPuzzle->getCubieInfo(myPuzzle->activeCubie).z <= 1) {
						dir = false;
					}
					if (closest==3) {
						dir=!dir;
					}

					rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,10);

				}


			}

			if (closest==4 || closest==5) {
				// z axis
				bHaveAxis = true;//we have to make shure to constrain the first gesture vector


				if (normalAng==0) {
					axis.x = 0;
					axis.y = 1;
					axis.z = 0;
					dir=true;
					if(myPuzzle->getCubieInfo(myPuzzle->activeCubie).x <= 1) {
						dir = false;
					}
					if (closest==5) {
						dir=!dir;
					}
					rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,10);

				} else {
					axis.x = 1;
					axis.y = 0;
					axis.z = 0;

					dir=true;
					if(myPuzzle->getCubieInfo(myPuzzle->activeCubie).y <= 1) {
						dir = false;
					}
					if (closest==5) {
						dir=!dir;
					}
					rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,10);

				}


			}
			
			*/


			if (closest == 0)
			{//1,0,0
				axis.x = 0;
				axis.y = 1;
				axis.z = 0;

				bHaveAxis = true;//we have to make shure to constrain the first gesture vector
				if(myPuzzle->getCubieInfo(myPuzzle->activeCubie).z >= 1) //>0 gridzise/2 for the other square armmatures
				{
					dir = true;
					rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,10);//need to find the "angle" 
				}
				else
				{
					dir = true;
					rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,10);
				}
			}

			if (closest == 1)
			{//-1,0,0
				axis.x = 0;
				axis.y = 1;
				axis.z = 0;

				bHaveAxis = true;
				if(myPuzzle->getCubieInfo(myPuzzle->activeCubie).z <=1)
				{
					dir = false;
					rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,10);
				}
				else
				{
					dir = false;
					rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,10);
				}
			}


			if (closest == 2)
			{//1,0,0
				axis.x = 0;
				axis.y = 0;
				axis.z = 1;

				bHaveAxis = true;//we have to make shure to constrain the first gesture vector
				if(myPuzzle->getCubieInfo(myPuzzle->activeCubie).x <= 1) //>0 gridzise/2 for the other square armmatures
				{
					dir = true;
					rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,10);//need to find the "angle" 
				}
				else
				{
					dir = false;
					rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,10);
				}
			}

			if (closest == 3)
			{//-1,0,0
				axis.x = 0;
				axis.y = 0;
				axis.z = 1;

				bHaveAxis = true;
				if(myPuzzle->getCubieInfo(myPuzzle->activeCubie).x <=1)
				{
					dir = false;
					rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,10);
				}
				else
				{
					dir = true;
					rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,10);
				}
			}

						if (closest == 4)
			{//1,0,0
				axis.x = 1;
				axis.y = 0;
				axis.z = 0;

				bHaveAxis = true;//we have to make shure to constrain the first gesture vector
				if(myPuzzle->getCubieInfo(myPuzzle->activeCubie).y >= 1) //>0 gridzise/2 for the other square armmatures
				{
					dir = true;
					rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,10);//need to find the "angle" 
				}
				else
				{
					dir = false;
					rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,10);
				}
			}

			if (closest == 5)
			{//-1,0,0
				axis.x = 1;
				axis.y = 0;
				axis.z = 0;

				bHaveAxis = true;
				if(myPuzzle->getCubieInfo(myPuzzle->activeCubie).y >=1)
				{
					dir = false;
					rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,10);
				}
				else
				{
					dir = true;
					rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,10);
				}
			}
	
	}

	}else{
		

		if (((dragDist-lastDragDistance)/300)>.5) {
			rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,5);
		} else if (((dragDist-lastDragDistance)/300)<-.5) {
			rotateByIDandAxis(myPuzzle->activeCubie,axis,dir,-5);
		}
	}
	lastDragDistance=dragDist;
}
